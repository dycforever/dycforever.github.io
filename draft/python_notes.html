<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="base_format.css">
</head>

<body>

 <h2>
《core python》笔记
 </h2>
    print可以像printf一样使用，但是用%来分割；<br>
    raw_input函数会自动去掉输入的回车符，然后将读到的内容作为返回值返回；<br>
    /表示整数除法，//表示浮点数除法；<br>
    and or not作为逻辑运算符链接各个条件；<br>
    python不支持++和--操作；<br>
    用[m:n] [-n]来获取数组元素，用+来表示字符串连接，*表示字符串重复<br>
    列表最外面是[]，tuple是()，tuple和列表都可以被切片，但是tuple不能被修改<br>
    字典由{}包含，键值之间由冒号分隔，键值对之间由逗号分隔<br>
<br>
    if expr1:<br>
    ........<br>
    elif expr2:<br>
    .......<br>
    else<br>
    .......<br>
<br>
    while expr :<br>
    ..........<br>
<br>
    range(n)函数表示0.1.2.....n-1<br>
    enumerate同时迭代数组下标和内容（下标在前）<br>
    可以用表达式后跟for循环、if判断来构造一个列表；这种方式叫做“list comprehension expression”，也可以用于初始化集合、字典等<br>
    列表可以嵌套<br>
<br>
    open函数和fopen差不多，不过可以用for var in fileobj的方法按行读文件<br>
    定义函数：def funcname (argulist)<br>
    可以x,y = y,x<br>
    type(obj)可以返回类型对象，None类型相当于void，None类型的值永远相当于NULL<br>
    str()和repr()都可以输入一个对象，输出对应的表述字符串，但是repr返回值可以通过eval()来还原对象<br>
    isinstance(obj, type)等价obj is type；还可以obj is not type<br>
<br>
    python没有字符类型；双引号和单引号几乎是等价的，只是用来避免不必要的转移而已<br>
    python中全都是对象，连int等内建类型多事引用指向的对象<br>
    可以用+来给元祖append元素；元祖有专用的index(n)和count(n)来引用和计算元素个数<br>
    list可以使用[:]来切片；使用in、not in来判断是否包含某元素；使用+来连接；使用*来重复；还可以在list中使用for和if来遍历<br>
    可作用于list的内建函数有：len()、max()、min()、sorted()、reversed()、enumerate()、zip()、sum()、list()、tuple()；可以使用list类内置的index函数返回指定元素在list中的位置<br>
    元祖tuple的 + 也是连接的意思；也可以使用list的大多数函数<br>
    可以使用copy模块的copy.deepcopy来进行对象的深拷贝<br>
    深拷贝对于原子类型的变量来说是没有意义的，比如数字、字符串、代码、类型等；一个tuple入如果只包含原子类型，也是不会被深copy的；个人觉得，只要是immutable的对象，都没有深copy的必要<br>
<br>
    for key in dict 这种语法可以直接遍历map中的所有key<br>
    map可以用用in 、not in来判断是否包含某元素<br>
    两个map的对比规则是：1、dict的长度；2、依次比较各个key；3、依次比较各个key的value；4、相等<br>
    zip()返回一个可迭代的对象，可以直接用dict()函数来接收该值，并构造map<br>
    map.items()函数以list的形式返回map的所有键值对，sorted(dict)返回排序后的所有keys<br>
<br>
    集合set内的元素是无序的，所以不能使用[]取下标或者slice操作，<br>
    set有可变与不可变，分别用set()和frozenset()构造；set的比较操作表示包含关系，可以使用&取并集，|取交集，-求差，^求差分（就是异或操作），返回的集合类型取决于操作符左边的集合类型<br>
<br>
    if使用not来取反，用and、or表示多条件<br>
<br>
    fileObj.tell() 返回文件指针的位置<br>
<br>
<br>
    <h2><br>
    《learning python》笔记<br>
    </h2><br>
    import某个模块，会把里面的语句都执行一遍，如果有print就会输出，但是其他模块中的变量不会和当前模块冲突；<br>
    如果使用exec函数，相当于是把那个文件的内容复制黏贴过来，那就会产生同名变量的冲突；<br>
    import一个模块，不会递归import它import的模块；<br>
    P89页有python中用到的各个类型<br>
    可以使用help(obj)函数来查看函数等对象的帮助文档<br>
    例子：ks = list(dict.keys()); ks.sort()<br>
    字典中直接引用不存在的key，会发生错误，所以引用之前要用in先判断一下：if k in dict:  ......<br>
    python中八进制数用0o或者0O来表示，就是零和任意case的字母O起头<br>
    在打印数字的时候可以使用类似C的方式来控制格式，还可以使用%e来表示科学计数法<br>
    可以用hex()、ort()、bin()来显示各种进制的数字，这几个函数还可以后跟进制来返回其他进制的值<br>
    set(obj)可以用iterable的对象来构造集合，集合支持：in、-、| (并)、&(交)、^、<、>(超集子集)等操作<br>
    空集必须由set()来显示构造，单一的{}是空字典<br>
    集合元素是不可修改的，python把immutable的也叫做hashable<br>
    python有专门的copy模块负责copy和deepcopy<br>
    ==是检测两个引用的值的相等性，而is是检测两个引用的本身的同一性<br>
<br>
    <h2><br>
        资料笔记<br>
    </h2><br>
    python3中，数据后面不用再加L来表示long类型，会出错<br>
<br>
<br>
    序列对象指的是可以使用索引运算符 s[i] 来访问，通过切片运算符 s[i:j] 可以得到一个子序列的对象(这些运算符在第四章有详细介绍)。<br>
    内建函数 len(s) 可以返回任意序列 s 的长度，内建函数 min(s) 和 max(s) 可以获得一个序列的最大值和最小值。<br>
<br>
    其中比较特殊的是缓冲区对象（buffer对象），它将内存的一个连续区域模拟为一个单字节字符序列。Python没有直接创建缓冲区对象的语句，你可以使用内建函数buffer(obj[,offset[,size]])来创建此类对象。 缓冲区对象与对象 obj 共享相同的内存，对于字符串切片操作或者其他字节数据操作来说，这样会有非常高的效率。另外， 缓冲区对象还可以用来访问其他Python类型储存的原始数据，比如array模块中的数组、 Unicode字符串等。缓冲器对象是否可变，取决于 obj 对象。<br>
<br>
    支持buffer接口的典型对象是string和array, string对象以面向字节的形式暴露字符内容.<br>
    使用buffer接口的对象是file对象的write(str)方法. 任何能通过buffer接口输出一系列字节的对象,都可以写到文件里<br>
<br>
    <h2><br>
    python调用C/C++<br>
    </h2><br>
<br>
    所有可以直接调用的函数原型都是：static PyObject * function(PyObject *self, PyObject *args)<br>
    当函数执行失败时，应该设置一个异常，并（通常）返回NULL。<br>
    该异常存储在一个解释器的全局变量中，为NULL表示没有异常发生，另有一个变量来存储异常相关的值；<br>
    如果错误是发生在python代码中的，还有第三个变量来存储straceback栈。这三个变量对应python中sys.exc_info()函数的返回值。<br>
    设置异常通常使用PyErr_SetString()函数；或者调用PyErr_SetFromErrno()，通过全局的errno来设置（常用的还有PyErr_SetObject()函数）。<br>
    PyErr_Occurred()函数可以用来测试代表异常的那个变量是否被赋值。<br>
    PyErr_Clear()则用来将其reset。<br>
<br>
    当Python中 import 一个C的模块时，PyInit_XXX()会被调用. <br>
    在函数内部，所有语句之前用"""包围的注释都会视为该函数的__doc__属性，可以直接访问funcname.__doc__输出。
    import的搜索路径可以访问sys.path来得到一个list，可以对该变量赋值来自定义。

</body>
