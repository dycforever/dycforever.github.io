<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="base_format.css">
</head>

<body>
<h2>
    notes
</h2>
<ul>
<li> .与source等价 </li> 
<li> 通配符中也有!、{}、[]等元字符，但是它们只作用于路径。 </li> 
<li> shell中的双引号和单引号，本质上就是用来关闭shell的meta字符 </li> 
<li> declare和typeset </li> 
<li> ${#VARIABLE_NAME} 可以给出字符串的长度 </li> 
<li> URL=${URL:-xxx} 如果变量不存在或者为空，则设置</li> 
<li> here documents便于输入多行文本：
<br>
command  &lt;&lt; MARKER
<br>
MARKER
</li> 
</ul>

<hr>
<h2>
    选项
</h2>
<ul>
<li> -e：如果一个命令失败就立即退出 </li> 
<li> -n：读入命令但是不执行它们 </li>
<li> -u：置换时把未设置的变量看作出错(可结合-e使用) </li>
<li> -v：当读入shell输入行时把它们显示出来 </li>
<li> -x：执行命令时把命令和它们的参数显示出来 <br>
上面的所有选项也可以在shell程序内部用“set -选择项”开启，“set +选择项”禁止。如果只想对程序的某一部分使用某些选择项时，则可以将该部分用上面两个语句包围起来。
</li>
</ul>

<hr>
<h2>
    特殊参数
</h2>
<ul>
<li>$*: 代表所有参数，视为一个字符串 </li>
<li>$@: 与*星号类同，相当于字符串数组 </li>
<li>$#: 代表参数数量，${#var}表示字符串的长度 </li>
<li>$?: 执行上一个指令的返回值 </li>
<li>$-: 最近执行的foreground pipeline的选项参数 </li>
<li>$$: 本身的Process ID </li>
<li>$!: 执行上一个背景指令的PID </li>
<li>$_: 显示出最後一个执行的命令 </li>
<li>  </li> 
</ul>

<hr>
<h2>
    字符串处理方式
</h2>
<ul>
<li> ${#var} 获取字符串长度 </li> 
<li> expr index "$variable" "target" 查找子串 </li> 
<li> echo ${var:start:length} 得到子串 </li> 
<li> 掐头去尾</li>
$echo ${variable#startletter*endletter} # #表示掐头,因为键盘上#在$前面,一个表示最小匹配 <br>
$echo ${variable##tartletter*endletter} 两个表示最大匹配 <br>
$echo ${variable%startletter*endletter} # %表示去尾,因为键盘上%在$后面,一个表示最小匹配 <br>
$echo ${variable%%startletter*endletter} 两个表示最大匹配  <br>

<li> 字符串替换 </li> 
$echo ${variable/oldletter/newletter} #替换一个
$echo ${variable//oldletter/newletter} #替换所有 
</ul>


<hr>
<h2>
    奇技
</h2>
<ul> 
<li> echo "{1..3}:{a..c}" </li>

<li> IFS=- read -ra parts <<< "foo-bar-baz"
在这里，-a 选项告诉read命令将分割后的元素保存到数组parts中。 随后可以通过${parts[0]}, ${parts[1]}来访问数组的各个元素，或者通过${parts[@]}来访问所有元素。 
</li>

<li> if [[ $file = *.zip ]]; then 用于通配符校验，还可以支持*?[] </li>
<li> if [[ $str =~ [0-9]+\.[0-9]+ ]]; then 用于正则匹配 </li> 
</ul>

</body>