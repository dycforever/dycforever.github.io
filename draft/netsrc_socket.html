<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="base_format.css">
</head>

data: 20140823

<body>
    一个socket对应内核中的一个struct socket，它有一个类型为struct proto_ops的成员ops，表示从socket函数到传输层对应函数的映射，对于tcp就是inet_stream_ops()。
    
    一个inet_protosw对应一个传输层协议，一个协议族的所有inet_protosw都存在静态的inetsw_array[]中；
    而系统所有的inet_protocol都记录在inetsw[]中，每种type对应数组中的一项。
    ipv4的inetsw_array[]定义在net/ipv4/af_inet.c中，包含了SOCK_STREAM/SOCK_DGRAM/SOCK_RAW三种type的socket，ipv4的SOCK_STREAM也就是TCP协议。

    一般一个协议族里，每种类型的传输类型都对应一个确定的协议，但是将来也许有除了TCP以外的SOCK_STREAM类型协议，因此socket层的bind/listen等函数，在调用传输层SOCK_STREAM中对应实现时，也要通过sock-&gt;sk_prot转换一下，TCP的struct proto实例是tcp_prot。

    socket也是一种文件系统，通过cat /proc/filesystems可以看到sockfs，对应sock_fs_type，它的成员用于。
    由此可见，一个struct file_system_type对应一个文件系统类型，它有分配/释放超级块的函数，因为一种文件系统可以装在多个分区上。
    而每个超级块有struct super_operations，用来分配/释放inode的函数，socket的inode其实是一个socket_alloc，socket文件的操作集合是socket_file_ops。

    <h2>
        bind()
    </h2>
    socket函数都使用系统调用sys_socketcall()，以socket listen为例：
    sys_socketcall()    net/socket.c
        =&gt; sys_bind()      net/socket.c
            =&gt; socket-&gt;ops-&gt;bind()     net/socket.c
                =&gt; inet_bind()    net/ipv4/af_inet.c
                    =&gt; sk-&gt;sk_prot-&gt;get_port()   net/ipv4/inet_connection_sock.c
                        =&gt; tcp_v4_get_port() net/ipv4/tcp_ipv4.c
    tcp没有tcp_bind()，所以sk-&gt;sk_prot-&gt;bind()为空，所以具体操作都在inet_bind()中。
    tcp_v4_get_port()本质上就是找一个可用的端口（如果没有显式指定），然后往系统全局的tcp_hashinfo-&gt;bhash[]中添加一个inet_bind_bucket结构，表示此端口已被占用。

    <h2>
        listen()
    </h2>
    sys_socketcall()    net/socket.c
        =&gt; sys_listen()      net/socket.c
            =&gt; socket-&gt;ops-&gt;listen()     net/socket.c
                =&gt; inet_listen()    net/ipv4/af_inet.c
                    =&gt; inet_csk_listen_start()    net/ipv4/inet_connection_sock.c
                        =&gt; reqsk_queue_alloc()   net/core/request_sock.c
                        =&gt; sk-&gt;sk_prot-&gt;get_port()   net/ipv4/inet_connection_sock.c
                            =&gt; tcp_v4_get_port() net/ipv4/tcp_ipv4.c
    inet_csk_listen_start()内会将sock的stat设置为TCP_LISTEN；一个监听socket对应一个inet_connection_sock，它有个成员icsq_accept_queue用来存储所有系统收到的建立连接请求。
    1.icsq_accept_queue中有成员resq_accept_head和rskq_accept_tail，表示已经完成三次握手，等待accept的连接；
	inet_listen()中会设置sk-&gt;sk_max_ack_backlog为backlog，表示建立连接队列的最大值。

    2.icsq_accept_queue还有个listen_sock类型的listen_opt成员，其中有一张syn_table hash表，用来存放所有接收到syn的半连接；
    listen_opt在reqsk_queue_alloc()中分配，syn_table的size是2^(backlog + 1)，同时把此hash表中可存放的半连接最大值lopt-&gt;max_qlen_log设置为backlog + 1；
    监听socket在接收到SYN后:
        1.用reqsk_queue_is_full()判断半连接队列(icsk_accept_queue)长度，里面也是用指数方法来判断是否超限。
        2.用sk_acceptq_is_full()判断已连接队列是否超过sk_max_ack_backlog

    <h2>
        accept()
    </h2>
    sys_socketcall()    net/socket.c
        =&gt; sys_accept()      net/socket.c
            =&gt; socket-&gt;ops-&gt;accept()     net/socket.c
                =&gt; inet_accept()    net/ipv4/af_inet.c
                    =&gt; sk-&gt;sk_prot-&gt;accept()   net/ipv4/af_inet.c
                        =&gt; inet_csk_accept() net/ipv4/inet_connection_sock.c


    receive first syn:
    tcp_v4_do_rcv()
        =&gt;tcp_rcv_state_process()
            =&gt;tcp_v4_conn_request()
                |=&gt;inet_csk_reqsk_queue_is_full()
                |=&gt;sk_acceptq_is_full()
                |=&gt;tcp_v4_save_options()
                |=&gt;tcp_v4_send_synack()
                    |=&gt;tcp_make_synack()
                    |=&gt;ip_build_and_send_pkt()
                |=&gt;inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);

    receive ack and finish 3-hands:
    tcp_v4_do_rcv()
        =&gt;tcp_v4_hnd_req()
            =&gt;tcp_check_req()
                =&gt;inet_csk_reqsk_queue_unlink()  check if valid ack
                    =&gt;inet_csk_reqsk_queue_add() add to icsk_accept_queue->resq_accept_head and backlog++


struct inet_ehash_bucket {
	struct hlist_head chain;
	struct hlist_head twchain;
};
根据四元组找sock时一般会在chain和twchain里面都找一遍。

struct inet_bind_hashbucket {
	spinlock_t		lock;
	struct hlist_head	chain;
};

代码上面注释解释了什么时候，端口是可以共享的，并重点说明了设置sk-&gt;sk_reuse时的情况
struct inet_bind_bucket {
	unsigned short		port;
	signed short		fastreuse;
	struct hlist_node	node;
	struct hlist_head	owners;
};


</body>

inet_protosw: include/net/protocol.h
struct socket: include/linux/net.h
struct proto_ops: include/linux/net.h
struct file_system_type sock_fs_type: net/socket.c
struct socket_alloc: include/net/sock.h
struct file_operations socket_file_ops: net/socket.c


struct sock: include/net/sock.h
struct proto: include/net/sock.h
struct proto tcp_prot: net/ipv4/tcp_ipv4.c

